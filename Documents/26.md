前のステップでは、エージェントが使う「道具 (**ツール**)」について学びました。自分でカスタムツールを作ったり、LangChain が用意してくれている便利なツールを使ったりできるようになりましたね。

さて、道具（ツール）を手に入れたエージェント。次なる疑問は「**その道具を、どうやって『考えて』使っているんだろう？**」ということではないでしょうか。ユーザーからの指示に対して、どのツールをどの順番で、どんな情報（引数）で呼び出すか…エージェントはこれを自分で判断しています。でも、その「考え方」には、実はいくつかの異なるスタイル＝**アーキテクチャ（構造）**があるんです！

このステップでは、LangChain で使われる代表的なエージェントのアーキテクチャ（思考の様式）を学び、それぞれの得意なことや特徴、そしてどんな時にどのタイプを選ぶのがベストなのか、そのヒントを探っていきます。エージェントの「考え方のクセ」を知って、あなたの目的にピッタリ合うエージェントを選べるようになりましょう！

## 1. はじめに：このステップで目指すこと

### 🎯 今回のゴール

このステップを最後まで読み終えると、あなたはこんなことができるようになります！

- エージェントの「思考回路」には複数の種類 (**アーキテクチャ**) があることを理解します。
- 現在主流となっている主要なアーキテクチャ、特に OpenAI モデルの能力を活用する **OpenAI Tools agent** と、段階的に思考する **ReAct** の仕組みと違いを学びます。
- 作りたいアプリケーションの目的や、使用する LLM の種類に応じて、どのアーキテクチャを選択すべきかの**判断基準**を持てるようになります。
- エージェントの本体 (**Agent** ロジック) と、それを動かす実行役 (**AgentExecutor**) が分離されている LangChain の設計思想に触れます。
- **具体的な成果物:** このステップは概念の理解が中心ですが、OpenAI Tools agent と ReAct の思考プロセスの違いを図や説明でイメージできるようになります。（具体的な実装は次のステップで！）

### 🔑 このステップのポイント

今回の「エージェントの頭の中を探る」旅で特に重要なキーワードはこちら！

- **エージェントアーキテクチャ / タイプ:** エージェントがどう考え、どうツールを使うかを決める基本設計。
- **OpenAI Tools agent:** OpenAI の **Tool Calling** 機能（旧 Function Calling）を使って、LLM が直接ツール呼び出しを決定するアーキテクチャ。
- **ReAct (Reason + Act):** **「思考 → 行動 → 観察」** のループで段階的に問題を解くアーキテクチャ。
- **Tool Calling:** LLM が応答の一部として、呼び出すべき関数（ツール）とその引数を構造化データで指定する機能。
- **推論プロセス (Reasoning Process):** エージェントが目標達成のために思考する手順。
- **Agent / AgentExecutor:** Agent は「何をするか決める」ロジック、AgentExecutor はそれを「実行する」ランタイム。
- **ツールの説明文 (Tool Description):** エージェントがツールを正しく理解し選択するために非常に重要！

### ✅ 前提知識

エージェントの思考法を学ぶ前に、これらは大丈夫ですか？

- **ステップ 24 & 25 の知識:** エージェントとは何か、そして **ツール** の概念とその重要性（特に**説明文**が大事！）を理解していること。
- **LLM の基本:** プロンプトを受け取って応答を生成する仕組みを知っていること。

準備ができたら、さまざまなエージェントの「考え方」を探っていきましょう！

---

## 2. 準備運動：エージェントにも「思考スタイル」がある！

### 🎯 目標

なぜ一つの考え方だけでなく、複数のエージェントアーキテクチャが存在するのか？ そして、代表的な **OpenAI Tools agent** と **ReAct** は、根本的にどう違うのか？ その基本的な考え方を掴みましょう。

### なぜアーキテクチャが複数あるの？

人間にも色々な問題解決スタイルがあるように、エージェントにもタスクや状況に応じて得意な「考え方」があります。LangChain では、様々なアプローチが研究・実装されており、開発者は目的に合ったアーキテクチャを選ぶことができます。

### 代表的な 2 つのスタイル：直感型？ それとも熟考型？

現在よく使われ、対照的な特徴を持つのがこの 2 つです。

1.  **OpenAI Tools agent (判断はお任せ！タイプ):**

    - **考え方:** 「この仕事には、どの道具が必要かな？ どう使うのがベストかな？」という判断を、主に **LLM 自身に委ねてしまう** スタイルです。
    - **仕組み:** **Tool Calling** という、OpenAI の比較的新しいモデル（最新の GPT-3.5 Turbo や GPT-4 など）が持っている特別な機能を利用します。LLM は、ユーザーの指示と利用可能なツールリストを見て、どのツールをどんな引数で呼び出すべきかを判断し、その指示を**構造化された形式 (JSON)** で直接返してくれます。LangChain はその指示を受け取ってツールを実行します。
    - **イメージ:** 優秀なアシスタントに「よしなにやっておいて！」と頼む感覚に近いかもしれません。

2.  **ReAct (じっくり考える！タイプ):**
    - **考え方:** 人間が問題を解くときのように、「うーん、まずは現状を**考えて (Thought)** みよう。よし、次はこれを**実行 (Action)** してみよう。その結果はどうかな？**観察 (Observation)** しよう。さて、次は…」という**思考のステップ**を一つ一つ明示的に踏んでいくスタイルです。
    - **仕組み:** LLM に対して、毎回「Thought: (考え)」「Action: (使うツールや最終回答)」「Observation: (ツールの実行結果)」という決まった形式でテキストを出力するように、特別なプロンプトで指示します。LangChain フレームワークが Action を読み取ってツールを実行し、その結果 (Observation) を次の思考の材料として LLM にフィードバックする、というループを繰り返します。
    - **イメージ:** 試行錯誤しながら、一歩一歩着実にゴールに向かう研究者のような進め方です。

このように、LLM の高度な判断能力に頼る方法と、思考プロセスを明示的に記述させる方法があり、それぞれにメリットとデメリットがあります。

---

## 3. 実践タイム：思考プロセスを覗いてみる

### 🎯 目標

このステップではコードを書きませんが、それぞれのアーキテクチャが内部でどのように動いているのか、その違いを具体的なイメージで掴みましょう。

### OpenAI Tools agent の思考イメージ

**ユーザー:** 「今日の東京の天気予報と、傘が必要か教えて」

**エージェントの内部的な動き (超簡略版):**

1.  LLM が指示（質問＋ツールリスト[天気検索ツール]）を受け取る。
2.  LLM が判断: 「天気検索ツールが必要だ。場所は東京。」
3.  LLM が応答 (例: Tool Call 指示):
    ```json
    {
      "tool_calls": [
        { "name": "search_weather", "arguments": { "location": "東京" } }
      ]
    }
    ```
4.  LangChain がこの指示を解釈し、`search_weather` ツールを `{"location": "東京"}` で実行。
5.  ツールが結果「降水確率 80%」を返す。
6.  LangChain がツール結果を LLM に渡し、「この結果から最終回答を作って」と依頼。
7.  LLM が最終回答「東京の天気は雨の可能性が高いです。傘を持っていくことをお勧めします。」を生成。

- **ポイント:** LLM が直接ツール呼び出しを指示している点。

### ReAct の思考イメージ

**ユーザー:** 「今日の東京の天気予報と、傘が必要か教えて」

**エージェントの内部的な動き (超簡略版):**

1.  **LLM への入力 1:** 質問 + ReAct 用プロンプト
2.  **LLM の出力 1:**
    ```
    Thought: 東京の天気を知りたい。天気検索ツールを使おう。
    Action: search_weather[東京]
    ```
3.  **(LangChain):** `search_weather` ツールを `東京` で実行。
4.  **LLM への入力 2:** 質問 + 思考履歴 + `Observation: 降水確率 80%`
5.  **LLM の出力 2:**
    ```
    Thought: 降水確率 80% なら傘は必要だ。最終的な答えを生成しよう。
    Action: Final Answer[今日の東京の天気は雨の可能性が高い(降水確率80%)ので、傘を持っていくことをお勧めします。]
    ```
6.  **(LangChain):** `Final Answer` を検出して終了。

- **ポイント:** LLM が「Thought:」「Action:」で思考と行動を段階的に記述している点。

### エージェント実行の仕組み：Agent と AgentExecutor

LangChain では、エージェントの仕組みは大きく二つに分かれています。

- **Agent:** LLM とプロンプトを含み、「次に何をすべきか（どのツールを呼ぶか、最終回答は何か）」を**決定する**ロジック部分。
- **AgentExecutor:** Agent が出した決定を受け取り、実際にツールを呼び出したり、LLM とのやり取りをループさせたりして、エージェントの処理全体を**実行・管理する**ランタイム部分。

次のステップでは、これらの部品を組み合わせてエージェントを動かします。今は「決定役」と「実行役」がいるんだな、と覚えておきましょう。

---

## 4. 深掘り解説：アーキテクチャ選びのヒント

### 🎯 目標

**OpenAI Tools agent** と **ReAct** のメリット・デメリットを比較し、どのような基準でアーキテクチャを選ぶべきか、その考え方を深めます。

### OpenAI Tools agent (Tool Calling 活用型)

- **仕組み:** OpenAI の `tools` パラメータ（以前の `functions`）を活用。LLM が自然言語とツール定義から、呼び出すべきツールと引数を JSON 形式で出力する能力に依存します。（GPT-3.5 Turbo の新しいバージョン、GPT-4、そして Anthropic Claude や Google Gemini の一部モデルなども対応が進んでいます。）
- **メリット:**
  - **シンプルさ:** LLM の能力に任せる部分が大きいため、プロンプトの設計が ReAct より簡単な傾向があります。
  - **効率性:** 思考ステップのテキストを生成しないため、トークン数が少なく、応答が速い可能性があります。
  - **複数ツール呼び出し:** 最新の `tools` では、一度に複数のツール呼び出しを計画・指示できます。
- **デメリット:**
  - **モデル依存:** 対応する LLM が必要です。
  - **デバッグの難しさ:** LLM がなぜそのツールを選んだのか、内部的な思考が見えにくいことがあります。
  - **複雑な計画の限界:** 非常に多くのステップが必要なタスクでは、一度に最適な計画を立てられない可能性も。
- **どんなときに良い？**
  - **Tool Calling 対応の高性能 LLM を使う場合。**
  - **比較的ストレートなツール利用で済むタスク。**
  - **応答速度や API コストが重要な場合。**
  - **LangChain の現在の推奨:** 対応モデルを使うなら、まず検討したい方法です。（`create_openai_tools_agent` 関数などで作成）

### ReAct (段階的思考型)

- **仕組み:** LLM に「Thought:」「Action:」「Observation:」の形式で思考と行動を段階的に生成させます。この形式を守らせるための、工夫されたプロンプトが必要です。
- **メリット:**
  - **思考の透明性:** エージェントの「考え」がテキストで出力されるため、デバッグや挙動分析がしやすいです。
  - **モデルの汎用性:** Tool Calling 機能がないモデルでも、プロンプト指示に従えれば動作する可能性があります。
  - **複雑な問題への対応力:** 問題を分解して考えるため、LLM が段階的に答えにたどり着きやすい場合があります。
- **デメリット:**
  - **プロンプトの複雑さ:** LLM に特定の思考形式を守らせる、洗練されたプロンプトが必要です。
  - **冗長性と速度:** 思考プロセスも出力するため、トークン消費量が多く、応答も遅くなりがちです。
  - **安定性:** LLM が形式を守らない、ループから抜け出せないなどの問題への対処が必要になることがあります。
- **どんなときに良い？**
  - **エージェントの思考プロセスを詳しく追いたい場合。**
  - **Tool Calling 非対応のモデルを使いたい場合。**
  - **段階的な試行錯誤が必要なタスク。**

### どうやって選ぶのがベスト？

LangChain は「これが絶対！」とは言わず、**ユースケースに応じて選択すること**を推奨しています。以下の点を考えてみましょう。

1.  **使う LLM:** Tool Calling 機能はあるか？ 十分な指示追従能力があるか？
2.  **タスクの性質:** ツール利用は単純か？ 複雑な計画や試行錯誤が必要か？
3.  **デバッグの重要度:** 思考プロセスを可視化する必要性は高いか？
4.  **速度とコスト:** リアルタイム応答や API コストの制約は厳しいか？

**まずは OpenAI Tools agent (対応モデルがあれば) から試し、それでうまく行かない場合や、思考プロセスを細かく見たい場合に ReAct を検討する**、という進め方が一つの有効なアプローチかもしれません。

また、これら以外にも **Structured Chat Agent** (チャット履歴を考慮した ReAct に近い) や、より高度な **Plan-and-Execute Agent** (まず計画を立ててから実行する) など、様々なアーキテクチャが LangChain には存在します。

---

## 5. 最終チェック：思考スタイルの違い、イメージできた？

### 🎯 目標

このステップで学んだ主要なエージェントアーキテクチャの違いと、選択のポイントを自分の言葉で説明できるか確認しましょう。

### 確認してみよう！

- **OpenAI Tools agent:** このエージェントは、どうやって次に使うツールを決めるんでしたっけ？ (ヒント: LLM にお任せ？)
- **ReAct:** このエージェントの思考プロセスは、どんなキーワードの繰り返しでしたか？ (ヒント: T... A... O...)
- **どっちが「見える」？:** エージェントが「何を考えているか」が分かりやすいのは、どちらのアーキテクチャでしょう？
- **使い分けシナリオ:** もし「とにかく速く簡単なツールを使って答えを出してほしい」なら、どちらを試しますか？ 逆に「なぜその結論に至ったのか、思考の跡をしっかり残してほしい」場合は？

これらの質問に答えられれば、エージェントの主な思考スタイルの違いは理解できています！

---

## 6. まとめ：学びの整理と次へのステップ

### ✅ 達成したこと！

これで、エージェントがどのように「考えて」ツールを使うのか、その裏にある複数の **アーキテクチャ** の存在とその違いを理解できました！

- エージェントの思考様式には複数の **アーキテクチャ（タイプ）** があることを学びました。
- 主要なアーキテクチャである **OpenAI Tools agent** (LLM の Tool Calling 機能活用) と **ReAct** (Thought-Action-Observation ループ) の基本的な仕組みと特徴を理解しました。
- それぞれのアーキテクチャの**メリット・デメリット**を知り、タスクや使用する LLM に応じて**選択するための判断基準**を学びました。
- **Agent** (決定ロジック) と **AgentExecutor** (実行ランタイム) の役割分担についても触れました。
- エージェントにとって**ツールの説明文**がいかに重要か、改めて認識しました。

### 🔑 学んだキーワード

- **エージェントアーキテクチャ (Agent Architecture) / エージェントタイプ (Agent Type)**
- **OpenAI Tools agent**
- **Tool Calling**
- **ReAct (Reason+Act)**
- **Thought / Action / Observation**
- **推論プロセス (Reasoning Process)**
- **Agent / AgentExecutor**
- **ツールの説明文 (Tool Description)**
- **トレードオフ (Trade-offs)**

### 🚀 次のステップへ！

エージェントの様々な「考え方」を知ったところで、次はいよいよ、これらのアーキテクチャを使って実際にエージェントを**組み立てて、動かして**みましょう！

次の **ステップ 27「自律実行！エージェントを動かそう」** では、今回学んだアーキテクチャ（特に現在の主流である OpenAI Tools agent を中心に）を選択し、ツールと LLM を組み合わせて、実際に自律的にタスクを実行するエージェントを作成・実行する具体的なコードを書いていきます。エージェントが自分の頭で考えてツールを使いこなす様子を、ぜひその目で確かめてください！
